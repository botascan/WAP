\documentclass{beamer}

\usepackage{svg}
\usepackage{tikz}
\usetheme{CambridgeUS}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% --- TITLE PAGE --- %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Breaking the Sorting Barrier for Directed Single-Source Shortest
Paths}

\subtitle{Duan et alii}
\author[Tascan, Durie, Lackner]{B. Tascan, B. Durie, S. Lackner}
\date[WAP 2025/26]{\today}

\setbeamertemplate{title page}{
    \begin{center}
        {\usebeamerfont{title}\inserttitle\par}
        \vspace{0.5cm}
        {\usebeamerfont{author}\insertauthor\par}
        \vspace{0.3cm}
        {\usebeamerfont{institute}\insertinstitute\par}
        \vspace{0.3cm}
        {\usebeamerfont{date}\insertdate\par}
        \vspace{0.50cm}
        \includegraphics[width=5.5cm]{logo1.png}
    \end{center}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% ---  --- %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\institute[PLUS]{
    FB Informatik\\
    Universität Salzburg
}
\setbeamertemplate{navigation symbols}{}

\AtBeginSubsection[]
{
  \begin{frame}
    %\frametitle{Verzeichnis}
    \tableofcontents[
        currentsection
    ]
  \end{frame}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% --- CUSTOMISE END --- %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}


\begin{frame}
    \titlepage
\end{frame}

\logo{
  \begin{minipage}{1cm}
    %\hfill
    \includegraphics[height=1cm]{logo2.png}
  \end{minipage}
}

\begin{frame}{Verzeichnis}
    \tableofcontents
\end{frame}

\section{Einführung}


\begin{frame}
    \begin{itemize}
        \item<1-> 
        \item<2-> 
        \item<3-> Datenstrukturen 
    \end{itemize}
\end{frame}

\subsection{SSSP Algorithmen}

\begin{frame}{SSSP Algorithmen}
    \begin{itemize}
        \item<1-> Single-Source Shortest Path Algorithmen (SSSP's) 
    \end{itemize}
\end{frame}

\subsubsection{Dijkstra}

\begin{frame}{Dijkstra}
    
\end{frame}

\subsubsection{Bellman-Ford}

\begin{frame}{Bellman-Ford}
    
\end{frame}

%BMSSP%
\section{Bounded Multi-Source Shortest Path}
\subsection{Der Algorithmus}

%Einleitung%
\begin{frame}{Der Algorithmus - Einleitung}
    \begin{columns}[c, onlytextwidth]
        \begin{column}{.5\textwidth}
            \begin{itemize}[<+->]
                \item Dijkstra in $\mathcal{O}(m + n\log n)$
                \item Sortierbarriere $\Omega(n\log n)$
            \end{itemize}
        \end{column}

        \begin{column}{.4\textwidth}
            \centering
            \fbox{
                \includesvg[width=\linewidth, height=0.7\textheight, keepaspectratio]{divide-and-conquer-1}
            }
        \end{column}

        \begin{column}{.1\textwidth}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}{Der Algorithmus - Lösungsansatz}
    Sortierbarriere umgehen durch:
    \vspace{0.6cm}
    
    \begin{itemize}[<+->]
        \item \textbf{Eigene Datenstruktur} \\ 
        Ermöglicht effizientes \textit{Bucketing}, verhindert Sortierung
        \vspace{0.4cm}
        
        \item \textbf{Pivoting} \\ 
        Reduziert den Rechenaufwand
        \vspace{0.4cm}
        
        \item \textbf{Divide \& Conquer} \\ 
        Mindert die Problemgröße durch Rekursion
    \end{itemize}
\end{frame}

%Divide and conquer%
\begin{frame}{Der Algorithmus - Divide \& Conquer}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.8\textheight]{divide-and-conquer-1}%
            }
        };
    \end{tikzpicture}
\end{frame}


\begin{frame}{Der Algorithmus - Divide \& Conquer}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.8\textheight]{divide-and-conquer-2}
            }
        };
        \node[
            fill=white,
            draw=beamer@blendedblue,
            thick, 
            rounded corners, 
            inner sep=8pt,
            opacity=0.9,
            text opacity=1,
            anchor=north east
        ] at ([xshift=-0.5cm, yshift=-1.8cm]current page.north east) {
            $2^t \text{ Partitionen mit } t = \lfloor \log^{2/3} n \rfloor$
        };

    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - Divide \& Conquer}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \includesvg[height=0.8\textheight]{divide-and-conquer-3}%
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - Divide \& Conquer}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.8\textheight]{divide-and-conquer-part-2}%
            }
        };
        \node[
            fill=white,
            draw=beamer@blendedblue,
            thick, 
            rounded corners, 
            inner sep=8pt,
            opacity=0.9,
            text opacity=1,
            anchor=north east
        ] at ([xshift=-0.5cm, yshift=-2.5cm]current page.north east) {
            $\lceil(\log n) /  t \rceil \text{ Rekursionen}$
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - Divide \& Conquer}
    Wozu das ganze?
    \vspace{0.6cm}
    ist notwendiges Hilfsmittel für:
    \begin{itemize}
        \item \textbf{BMSSP} \\ 
        funktioniert nur dank Abgrenzungen
        \vspace{0.4cm}
        \item \textbf{Pivots} \\ 
        erlaubt schnelle Auswahl von wichtigen Knoten
    \end{itemize}
\end{frame}

%BMSSP
\begin{frame}{Der Algorithmus - BMSSP}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.6\textheight]{bmssp-1}%
            }
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - BMSSP}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.6\textheight]{bmssp-2}%
            }
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - BMSSP}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.6\textheight]{bmssp-3}%
            }
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - BMSSP}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.6\textheight]{bmssp-4}%
            }
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - BMSSP}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.6\textheight]{bmssp-4}%
            }
        };
        \node[
            fill=white,
            draw=beamer@blendedblue,
            thick, 
            rounded corners, 
            inner sep=8pt,
            opacity=0.9,
            text opacity=1,
            anchor=north east
        ] at ([xshift=-0.5cm, yshift=-2cm]current page.north east) {
            Konkrete Suche via Mini-Dijkstra über $k$-Schritte
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - BMSSP}
    Wozu das ganze?
    \vspace{0.6cm}
    \begin{itemize}
        \item \textbf{Sortierbarriere} \\ 
        Ermöglicht Umgehung der $\Omega(n\log n)$ Schranke dank Bucketing
    \end{itemize}
\end{frame}

%Pivots%
\begin{frame}{Der Algorithmus - Pivots}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.8\textheight]{pivots-1}%
            }
        };
        \node[
            fill=white,
            draw=beamer@blendedblue,
            thick, 
            rounded corners, 
            inner sep=8pt,
            opacity=0.9,
            text opacity=1,
            anchor=north east
        ] at ([xshift=-0.25cm, yshift=-1.25cm]current page.north east) {
            $k$ Bellmann-Ford Schritte
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - Pivots}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.8\textheight]{pivots-2}%
            }
        };
        \node[
            fill=white,
            draw=beamer@blendedblue,
            thick, 
            rounded corners, 
            inner sep=8pt,
            opacity=0.9,
            text opacity=1,
            anchor=north east
        ] at ([xshift=-0.25cm, yshift=-1.25cm]current page.north east) {
            \text{Markiere Knoten anhand nähester Quelle}
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - Pivots}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.8\textheight]{pivots-2}%
            }
        };
        \node[
            fill=white,
            draw=beamer@blendedblue,
            thick, 
            rounded corners, 
            inner sep=8pt,
            opacity=0.9,
            text opacity=1,
            anchor=north east
        ] at ([xshift=-0.25cm, yshift=-1.25cm]current page.north east) {
            Bäume mit mindestens $k$ Knoten $\Rightarrow$ Pivots
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - Pivots}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.8\textheight]{pivots-2}%
            }
        };
        \node[
            fill=white,
            draw=beamer@blendedblue,
            thick, 
            rounded corners, 
            inner sep=8pt,
            opacity=0.9,
            text opacity=1,
            anchor=north east
        ] at ([xshift=-0.25cm, yshift=-1.25cm]current page.north east) {
            Bäume mit mindestens $k$ Knoten $\Rightarrow$ Pivots
        };
        \node[
            fill=white,
            draw=beamer@blendedblue,
            thick, 
            rounded corners, 
            inner sep=8pt,
            opacity=1,
            text opacity=1,
            anchor=center,
            align=center
        ] at (current page.center) {
            Maximal $n/k$ Bäume mit mindestens $k$ Knoten \\
            $\Rightarrow$ Maximal $n/k$ Pivots
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - Pivots}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.8\textheight]{pivots-3}%
            }
        };
        \node[
            fill=white,
            draw=beamer@blendedblue,
            thick, 
            rounded corners, 
            inner sep=8pt,
            opacity=1,
            text opacity=1,
            anchor=north east,
            align=center
        ] at ([xshift=-0.25cm, yshift=-1.25cm]current page.north east) {
            Weiterführende Bäume müssen unterste Schicht erreichen. \\
            Nur Bäume mit mindestens $k$ Knoten (=Pivots) können das.
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - Pivots}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.8\textheight]{pivots-4}%
            }
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - Pivots}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.8\textheight]{pivots-4}%
            }
        };
        \node[
            fill=white,
            draw=beamer@blendedblue,
            thick, 
            rounded corners, 
            inner sep=8pt,
            opacity=1,
            text opacity=1,
            anchor=center,
            align=center
        ] at (current page.center) {
            Alle nicht-Pivot-Knoten vorab berechnet \\
            $\Rightarrow$ Nur Pivots werden weiterverfolgt
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - Pivots}
    Wozu das ganze?
    \vspace{0.6cm}
    Hauptgrund für Geschwindigkeit:
    \begin{itemize}
        \item \textbf{Kostenreduktion} \\ 
        reduziert Aufwand durch gezielte Knotenwahl
        \vspace{0.4cm}
        \item \textbf{Faktor} \\ 
        reduziert BMSSP Knotenanazahl um $\log^{1/3} n$
    \end{itemize}
\end{frame}

\begin{frame}{Der Algorithmus - Letzte Hürde}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.8\textheight]{hurdle-1}%
            }
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - Letzte Hürde}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.8\textheight]{hurdle-2}%
            }
        };
        \node[
            fill=white,
            draw=beamer@blendedblue,
            thick, 
            rounded corners, 
            inner sep=8pt,
            opacity=1,
            text opacity=1,
            anchor=north east,
            align=center
        ] at ([xshift=-0.5cm, yshift=-1.5cm]current page.north east) {
            Unerwartet viele Knoten in Partition
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{Der Algorithmus - Letzte Hürde}
    \begin{tikzpicture}[remember picture, overlay]
        \node at ([yshift=-0.5cm]current page.center) {
            \fbox{%
                \includesvg[height=0.8\textheight]{hurdle-3}%
            }
        };
    \end{tikzpicture}
\end{frame}
\subsection{Die Datenstruktur}

\begin{frame}{Die Datenstruktur}
    \begin{itemize}
        \item<1-> Dijkstra hat eine asymptotische Laufzeit von $\mathcal{O}(m\log n)$
        \item<2-> Um diese Laufzeit zu verbessern, wird eine spezielle Datenstruktur benötigt
        \item<3-> Diese Struktur ist eine sogenannte Block-based linked List
    \end{itemize}
\end{frame}

\begin{frame}{Die Datenstruktur}
    \begin{itemize} 
        \item<1-> Es gibt zwei Sequenzen an Blöcken, $\mathcal{D}_0$ und $\mathcal{D}_1$, welche beide Linked Lists sind mit maximal M Key/Value Paaren und einem Upperbound von B
        \item<2-> $\mathcal{D}_0$ enthält Batch Prepend Elemente, unbounded
        \item<3-> $\mathcal{D}_1$ enthält mit Insert eingefügte Elemente, bounded mit $O(\max\{1, N/M\})$
    \end{itemize}
    \only<3->{
        \begin{center}
            \includegraphics[width=0.7\textwidth]{test-6.pdf}
        \end{center}
    }
\end{frame}

\begin{frame}{Die Datenstruktur}
    \begin{itemize}
        \item<1-> Beide Sequenzen sind nach deren Werten sortiert, d.h. der Upperbound eines Blocks ist nie größer als alle Werte des darauffolgenden Blocks
        \item<2-> Die Blöcke werden von einem binären Suchbaum gebalanced
    \end{itemize}
    \only<2>{
        \begin{center}
            \includegraphics[width=0.5\textwidth]{block1.pdf}
        \end{center}
    }
    \only<3>{
        \begin{center}
            \includegraphics[width=0.7\textwidth]{sequenzorder-1.pdf}
        \end{center}
    }
\end{frame}

\begin{frame}{Die Datenstruktur}
    \begin{itemize}
        \item<1-> Insert
        \item<2-> Batch Prepend
        \item<3-> Pull
    \end{itemize}
\end{frame}

\begin{frame}{Die Datenstruktur}
    \begin{itemize}
        \item<1-> Insert(a, b):
        \item<2-> Sollten mehrere Key/Value Paare den selben Key haben, so wird das Paar mit dem kleineren Value bevorzugt
        \item<3-> Der entsprechende Block wird mithilfe des Binären Baums gesucht
        \item<4-> Insert beim gefunden Block in$\mathcal{D}_1$
        \item<5-> Laufzeit von Insert $O(\max\{1, \log(N/M)\})$
    \end{itemize}
\end{frame}

\begin{frame}{Die Datenstruktur}
    \begin{itemize}
        \item<1-> Batch Prepend(L):
        \item<2-> L Key/value Paare werden so eingetragen dass keine kleineren Werte vorhanden sind
        \item<3-> Insert ist immer am Beginn von $\mathcal{D}_0$
        \item<4-> Laufzeit von Batch Prepend $O(L \cdot \max\{1, \log(L/M)\})$
    \end{itemize}
\end{frame}

\begin{frame}{Die Datenstruktur}
    \begin{itemize}
        \item<1-> Pull:
        \item<2-> Pull gibt eine Menge S', mit einem Upper Bound x, an kleinsten Werten zurück 
        \item<3-> Das führt zu einer Sortierung in Gruppen statt einer genauen Sortierung der Werte
        \item<4-> Laufzeit von Pull $O(|S'|)$
    \end{itemize}
\end{frame}

\subsection{Der Algorithmus}
\subsection{Laufzeit}

\section{Literatur}

\begin{frame}{Literatur}
    
\end{frame}


\end{document}
